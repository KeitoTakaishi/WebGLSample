<html>
	<head>
		<title>My first three.js app</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="../../Three_js/build/three.js"></script>
		<script>
      var scene, camera, renderer, geometry;
      var particles = 300000;
			scene = new THREE.Scene();
			camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );
      camera.position.set(0, 0.0, 10.0);
      camera.lookAt(new THREE.Vector3());

			renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );

      var ParamsShaderMaterial = {
        uniforms: {
          "time": {value: 1.0}
        },
        vertexShader: [
          "precision mediump float;",
          "attribute vec4 color;",
          "uniform float time;",
          "varying vec4 vColor;",
          "void main() {",
          "vColor = color;",
          "gl_PointSize = 1.5;",
					//"vec3 p = vec3(position.x, position.y * 10.0 * sin(100.0*(position.x + position.z) + time/1000.0), position.z);",
          "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
          "}"
        ].join( "\n" ),
        fragmentShader: [
          "precision mediump float;",
          "uniform float time;",
          "varying vec4 vColor;",
          "void main() {",
          "float t = time * 0.001;",
					"gl_FragColor = vec4(vColor);",
          //"gl_FragColor = vec4( vColor.r * abs(sin(t)), vColor.g * abs(cos(t)), vColor.b * abs(sin(t)), 1.0 );",
          "}"
        ].join( "\n" ),
        //side: THREE.DoubleSide,
        transparent: false
      }
      init();
      animate();

      function init(){
				//-----------------

				//sample01
        // geometry = new THREE.BufferGeometry();
        // let positions = [];
        // let colors = [];
        // let x, y, z;
        // for(let i = 0; i < particles; i++){
        //   x = Math.random() * 2.0 - 1.0;
        //   y = Math.random() * 2.0 - 1.0;
        //   z = Math.random() * 2.0 - 1.0;
        //   if(x * x + y * y + z * z <= 1) {
        //     positions.push(x * 500.0);
        //     positions.push(y * 10.0);
        //     positions.push(z * 500.0);
        //     colors.push(Math.random() * 255.0);
        //     colors.push(Math.random() * 255.0);
        //     colors.push(Math.random() * 255.0);
        //     colors.push(Math.random() * 255.0);
        //   }
        // }
        // let positionAttribute = new THREE.Float32BufferAttribute(positions, 3);
        // let colorAttribute = new THREE.Uint8BufferAttribute(colors, 4);
        // colorAttribute.normalized = true;
        // geometry.addAttribute( 'position', positionAttribute );
        // geometry.addAttribute( 'color', colorAttribute );


				//sample02
				var geometry = new THREE.BufferGeometry();
				var vertexPositions = [
					[-1.0, -1.0, 1.0],
					[1.0 , -1.0, 1.0],
					[1.0 ,  1.0, 1.0],
					[-1.0 , 1.0, 1.0]
				];

				var vertices = new Float32Array(vertexPositions.length * 3);
				let colors = [];
				for (var i = 0; i < vertexPositions.length; i++) {
				    vertices[i * 3 + 0] = vertexPositions[i][0];
				    vertices[i * 3 + 1] = vertexPositions[i][1];
				    vertices[i * 3 + 2] = vertexPositions[i][2];
						colors.push(255.0);
						colors.push(0.0);
						colors.push(0.0);
						colors.push(255.0);

				}
				let colorAttribute = new THREE.Uint8BufferAttribute(colors, 4);
				colorAttribute.normalized = true;
				var indices = new Uint16Array([
				    0, 1, 2,
				    2, 3, 0
				]);

				geometry.addAttribute('position', new THREE.BufferAttribute(vertices, 3));
				//geometry.addAttribute('index',    new THREE.BufferAttribute(indices,  1));
				geometry.setIndex(new THREE.BufferAttribute(indices,1));
				geometry.addAttribute( 'color', colorAttribute );

				//------------------

        material = new THREE.ShaderMaterial(ParamsShaderMaterial);

        mesh = new THREE.Points(geometry, material);
				mesh.position.z = -10;
        scene.add(mesh);
      }

      function animate(){
        requestAnimationFrame(animate);
        render();
      }

      function render(){
        time = performance.now();
        material.uniforms.time.value = time;
        renderer.render(scene, camera);
      }



	   </script>
	</body>
</html>
