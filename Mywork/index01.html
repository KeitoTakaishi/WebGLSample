<!DOCTYPE html>
<html>

<head>
  <title>Example 11.02 - Simple passes</title>
  <script type="text/javascript" src="../libs/three.js"></script>
  <script type="text/javascript" src="../libs/Tween.js"></script>

  <script type="text/javascript" src="../libs/stats.js"></script>
  <script type="text/javascript" src="../libs/dat.gui.js"></script>
  <script type="text/javascript" src="../libs/controls/OrbitControls.js"></script>
  <script type="text/javascript" src="../libs/postprocessing/EffectComposer.js"></script>
  <script type="text/javascript" src="../libs/postprocessing/ShaderPass.js"></script>
  <script type="text/javascript" src="../libs/shaders/CopyShader.js"></script>

  <script type="text/javascript" src="../libs/postprocessing/BloomPass.js"></script>
  <script type="text/javascript" src="../libs/shaders/ConvolutionShader.js"></script>

  <script type="text/javascript" src="../libs/postprocessing/DotScreenPass.js"></script>
  <script type="text/javascript" src="../libs/shaders/DotScreenShader.js"></script>


  <script type="text/javascript" src="../libs/postprocessing/MaskPass.js"></script>
  <script type="text/javascript" src="../libs/postprocessing/FilmPass.js"></script>
  <script type="text/javascript" src="../libs/shaders/FilmShader.js"></script>
  <script type="text/javascript" src="../libs/postprocessing/RenderPass.js"></script>
  <script type="text/javascript" src="../libs/postprocessing/TexturePass.js"></script>

  <!-- Glitch -->
  <script type="text/javascript" src="../libs/postprocessing/GlitchPass.js"></script>
  <script type="text/javascript" src="../libs/shaders/DigitalGlitch.js"></script>

  <!-- original -->
  <script type="text/javascript" src="../libs/postprocessing/Edge.js"></script>
  <script type="text/javascript" src="../libs/postprocessing/blur.js"></script>
  <script type="text/javascript" src="../libs/postprocessing/PartyShader.js"></script>


  <!-- Midi-->
  <script type="text/javascript" src="Midi.js"></script>
  <script type="text/javascript" src="MidiValue.js"></script>


  <style>
    body {
            /* set margin to 0 and overflow to hidden, to go fullscreen */
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>

<body>

  <div id="Stats-output">
  </div>
  <!-- Div which will hold the Output -->
  <div id="WebGL-output">
  </div>

  <!-- Javascript code that runs our Three.js examples -->
  <script type="text/javascript">
    // once everything is loaded, we run our Three.js stuff.
    function init() {
      var isEdgeShader = true;
      var isGlitchShader = true;

      var stats = initStats();
      var scene = new THREE.Scene();
      scene.fog = new THREE.Fog(0x000000, 1, 1000);
      var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
      var webGLRenderer = new THREE.WebGLRenderer();
      webGLRenderer.setClearColor(new THREE.Color(0x000));
      webGLRenderer.setSize(window.innerWidth, window.innerHeight);
      webGLRenderer.shadowMap.enabled = true;

      //main-object-------------------------------------------
      object = new THREE.Object3D();
      scene.add(object);
      var geometry = new THREE.SphereBufferGeometry(1, 4, 4);
      var material = new THREE.MeshPhongMaterial({
        color: 0x222222,
        flatShading: true
      });
      var wireMat = new THREE.MeshPhongMaterial({
        color: 0xfffff, //球の色
        wireframe: true //ワイヤーフレーム有効
      });

      for (var i = 0; i < 100; i++) {
        var mesh = new THREE.Mesh(geometry, material);
        mesh.position.set(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize();
        mesh.position.multiplyScalar(Math.random() * 200);
        mesh.rotation.set(Math.random() * 2, Math.random() * 2, Math.random() * 2);
        mesh.scale.x = mesh.scale.y = mesh.scale.z = Math.random() * 5;
        object.add( mesh );

        var wireMesh = new THREE.Mesh(geometry, wireMat);
        wireMesh.position.set(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize();
        wireMesh.position.multiplyScalar(Math.random() * 100);
        wireMesh.rotation.set(Math.random() * 2, Math.random() * 2, Math.random() * 2);
        wireMesh.scale.x = wireMesh.scale.y = wireMesh.scale.z = Math.random() * 5;
        object.add( wireMesh );
      }

      //main-object-------------------------------------------
      var particles = new THREE.Object3D();
      var geometry = new THREE.SphereBufferGeometry(1, 4, 4);
      var wireMat = new THREE.MeshPhongMaterial({
        color: 0xfffff, //球の色
        wireframe: true //ワイヤーフレーム有効
      });
      // for (var i = 0; i < 100; i++) {
      //   var particle = new THREE.Mesh(geometry, wireMat);
      //   wireMesh.position.set(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize();
      //   wireMesh.position.multiplyScalar(Math.random() * 100);
      //   wireMesh.rotation.set(Math.random() * 2, Math.random() * 2, Math.random() * 2);
      //   wireMesh.scale.x = wireMesh.scale.y = wireMesh.scale.z = Math.random() * 5;
      //   object.add(wireMesh);
      // }

      //------------------------------------------------------
      var particles = new Array(100);
      var mat = new THREE.MeshPhongMaterial({
        color: 0x6699FF,
        wireframe: true,
      });
      for (var i = 0; i < 100; i++) {
        particles[i] = new THREE.Mesh(geometry, mat);
        particles[i].scale.set(10, 10, 10);
        scene.add(particles[i]);
      }


      // position and point the camera to the center of the scene
      camera.position.x = -10;
      camera.position.y = 15;
      camera.position.z = 400;

      camera.lookAt(new THREE.Vector3(0, 0, 0));

      var orbitControls = new THREE.OrbitControls(camera);
      orbitControls.autoRotate = false;
      var clock = new THREE.Clock();

      var ambi = new THREE.AmbientLight(0xffffff);
      scene.add(ambi);

      var spotLight = new THREE.DirectionalLight(0xffffff);
      spotLight.position.set(550, 100, 750);
      spotLight.intensity = 0.6;

      scene.add(spotLight);

      // add the output of the renderer to the html element
      document.getElementById("WebGL-output").appendChild(webGLRenderer.domElement);


      //shader
      var renderPass = new THREE.RenderPass(scene, camera);
      var effectCopy = new THREE.ShaderPass(THREE.CopyShader);
      effectCopy.renderToScreen = true;

      //bloom
      var bloomPass = new THREE.BloomPass(2.5, 25, 105.0, 256);
      var effectFilm = new THREE.FilmPass(0.8, 0.325, 256, false);
      effectFilm.renderToScreen = true;

      //current
      var composer = new THREE.EffectComposer(webGLRenderer);
      // composer.addPass(renderPass);
      // composer.addPass(effectCopy);
      var renderScene = new THREE.TexturePass(composer.renderTarget2);


      //pass2->bloom
      var composer2 = new THREE.EffectComposer(webGLRenderer);
      // composer2.addPass(renderScene);
      // composer2.addPass(bloomPass);


      //edgeshader
      var EdgeShader = new THREE.EdgePass();
      EdgeShader.renderToScreen = isEdgeShader;
      //composer2.addPass(renderScene);



      //PartyShader----------------------
      var subCam = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
      subCam.position.x = -10;
      subCam.position.y = 15;
      subCam.position.z = 400;

      var width = window.innerWidth,
        height = window.innerHeight;
      var bufferTexture = new THREE.WebGLRenderTarget(width, height, {
        magFilter: THREE.NearestFilter,
        minFilter: THREE.NearestFilter,
        wrapS: THREE.ClampToEdgeWrapping,
        wrapT: THREE.ClampToEdgeWrapping
      });

      //generate RT
      webGLRenderer.render(scene, subCam, bufferTexture, true);

      //GlitchShader
      var effectGlitch = new THREE.GlitchPass(64);
      effectGlitch.renderToScreen = isGlitchShader;


      //addPass
      composer.addPass(renderPass);
      composer.addPass(effectCopy);
      composer2.addPass(renderScene);
      composer2.addPass(bloomPass);
      composer2.addPass(effectGlitch);
      composer2.addPass(EdgeShader);



      //light
      scene.add(new THREE.AmbientLight(0x222222));
      light = new THREE.DirectionalLight(0xffffff);
      light.position.set(1, 1, 1);
      scene.add(light)



      //test renderTexture Map
      var boxMaterial = new THREE.MeshPhongMaterial({
        map: bufferTexture.texture
      });
      var boxGeometry2 = new THREE.BoxGeometry(100, 100, 100);
      var mainBoxObject = new THREE.Mesh(boxGeometry2, boxMaterial);
      scene.add(mainBoxObject);

      // call the render function
      var step = 0;



      var t = 0.0;
      var size = 100;
      var vel_x = new Array(size);
      var vel_y = new Array(size);
      var vel_z = new Array(size);
      for (var i = 0; i < size; i++) {
        vel_x[i] = 30.0 * (0.5 - Math.random(1.0));
        vel_y[i] = 30.0 * (0.5 - Math.random(1.0));
        vel_z[i] = 30.0 * (0.5 - Math.random(1.0));
      }

      //Tween-------------------------------------
      var posSrc = {rotation: 0}; // 初期値
      var tween = new TWEEN.Tween(posSrc)
             .to({rotation: 180}, 3000)
             .easing(TWEEN.Easing.Circular.In);
      var tweenBack = new TWEEN.Tween(posSrc)
            .delay(3000)
            .to({rotation: 0}, 3000)
            .easing(TWEEN.Easing.Circular.In);

      tween.chain(tweenBack);
      tweenBack.chain(tween);

      var onUpdate = function () {
        var count = 0;
        var rotation = this.rotatiom; // this == {pos: 1}
        mainBoxObject.rotation.x = rotation;
        mainBoxObject.rotation.y = rotation;
        mainBoxObject.rotation.z = rotation;
      };
      tween.onUpdate(onUpdate);
      tweenBack.onUpdate(onUpdate);
      tween.start();
      //------------------------------------------

      render();

      function render() {
        TWEEN.update();


        t += 0.05;
        if (Number.isNaN(t)) {
          t = 0.0;
        }
        camera.position.x = 250.0*Math.sin( t % 360.0 );
        camera.position.z = -knob[0]*10.0 + 250.0*Math.cos( t % 360.0);
        //camera.position.z = knob[0]*10.0;
        camera.position.y = knob[0]*5.0+50*Math.sin( t % 360.0 );

        stats.update();
        var delta = clock.getDelta();
        orbitControls.update(delta);

        // render using requestAnimationFrame
        requestAnimationFrame(render);

        webGLRenderer.autoClear = false;
        webGLRenderer.clear();
        //object.rotation.x += 0.05;
        //object.rotation.y += 0.03;

        if (button[0] >= 127) {
          for (var i = 0; i < size; i++) {
            particles[i].position.set(0, 0, 0);
            button[0] = 0;
          }
          isEdgeShader =  !isEdgeShader;
          EdgeShader.renderToScreen = isEdgeShader;

          if(isEdgeShader){
            // composer.addPass(renderPass);
            // composer.addPass(effectCopy);
            // composer2.addPass(renderScene);
            // composer2.addPass(bloomPass);
             composer2.addPass(EdgeShader);
            //composer2.addPass(effectGlitch);
          }
          button[0] = 10;
        }else if(button[1] >= 127){
          isGlitchShader = !isGlitchShader;
          effectGlitch.goWild = isGlitchShader;
          button[1] = 10;
        }

        //mainRender
        webGLRenderer.setViewport(0, 0, window.innerWidth, window.innerHeight);
        //composer2.addPass(PartyShader);
        composer.render(delta);
        composer2.render(delta);


        //buffer
        webGLRenderer.render(scene, subCam, bufferTexture, true);
        webGLRenderer.render(scene, subCam);
        //PartyShader.uniforms.tex.value = bufferTexture.texture;

        for (var i = 0; i < size; i++) {
          if (Math.abs(particles[i].position.x) < 500) {
            particles[i].position.x += vel_x[i];
            particles[i].position.y += vel_y[i];
            particles[i].position.z += vel_z[i];
            particles[i].rotation.x += vel_x[i];
            particles[i].rotation.z += vel_x[i];
          }
        }
      }

      function initStats() {

        var stats = new Stats();
        stats.setMode(0); // 0: fps, 1: ms

        // Align top-left
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.left = '0px';
        stats.domElement.style.top = '0px';

        document.getElementById("Stats-output").appendChild(stats.domElement);

        return stats;
      }
    };

    window.onload = init;
  </script>
</body>

</html>
